This sample project illustrates the basic functionality of SQL+.NET code generation, as well
as illustrates how the generated code can be utilized in various client applications.

*NOTE

1) SQL+.NET is a SQL first ORM, so you need a database. Use the dbscript.txt to create that database 
	and the DB objects used moving forward. The SqlPus.Data project contains the code that was 
	generated using SQL+.NET - feel free to explore the generated code.

2) Edit the connection string in the project SqlPlusDemo.Settings project at ConnectionStrings.cs pointing 
	it to the database you created in step 1

3) You can now run the test project - From the menu select Test>>Run All Test
	a) Double click on an individual test to go directly to the code.
	b) Some tests write line to the console - in the text explorer wwindow click on >> open additional output for this result.
	b) **Before any subsequent test runs, execute the primefeedbacktests.txt**
	c) Explore the code in the test project.

4) Execute the seeddata.txt

5) Right click on the SqlPlusDemo.Web project and select debug>>start new instance
	a) Click the Submit link
		1) Try submitting the form with invalid data.
		2) Try submitting the form with valid data.
		3) Try submitting the form with the names scott hanselman.
		3) Add a break point on the home controller [HttpPost] Feedback action and step through the code
	b) Click the View Page link
		1) Try different pages by clicking the number links
		2) Try the delete functionality
		3) Add a break point on either of the actions in the FeedbackAdminController and step through the code
	c) Have a look at the FeedbackInputViewModel, which derives from the input class, adds properties specific to
	   the html form, and overrides the validation.

5) Right click on the SqlPlus.Data.Functions project and select debug>>start new instance
	a) Fire up postman
	b) Try the feedback paged routine *get* - http://localhost:7071/api/Feedback/1/20 - different pages and sizes - the range for page size is 10-50
	c) Try the feedback by id routine *get* - http://localhost:7071/api/Feedback/1 with different values for the id
	d) Try the feedback upsert routine *post* - http://localhost:7071/api/Feedback
		1)Post inserts a new record
			{
			"lastName": "LastName-1",
			"firstName": "FirstName-1",
			"email": "Email1@somewhere.com",
			"subject": "Subject-1",
			"message": "Message-1",
			"created": "2019-12-03T21:08:39.3515481"
		  }
	e) Try the feedback upsert routine *put* http://localhost:7071/api/Feedback
		1)Put updates an existing record
		 {
			"feedbackId": 21,
			"lastName": "LastName-1",
			"firstName": "FirstName-1",
			"email": "Email1@somewhere.com",
			"subject": "Subject-1",
			"message": "Message-1",
			"created": "2019-12-03T21:08:39.3515481"
		 }
	f) Try the feedback delete - http://localhost:7071/api/Feedback/100 - with different values

6) Leave the azure function app running and start the blazor application 
	a) Notice that the input models in the blazor app are only linked to the project so we don't need to include the entire class library
	b) Try submitting feedback - and notice we added no validation to our calls as this is all handled by the models

**************************************************************************************************************

Greetings, I'm alan hyneman, creator of SQL+.NET, and I hope after exploring the sample applications
you've gained some insight, and see the value in this tool. 

What you will find when building services this way, is that you can be very productive, all the why building highly optimized
code that will hold up in even the most demanding environments. 

I have two simple requests for you
	1) If you DON'T like the product, let me know why. Alan@SQLPLUS.net
	2) If you DO like the product, tell your friends and coworkers about it.

web: www.SqlPlus.net
twitter: @SQLPLUSDOTNET
facebook: www.facebook.com/sqlplusdotnet
linkedin: www.linkedin.com/in/alanhynemandev

Sincerely,
Alan Hyneman

